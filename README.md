# 联想笔试题

笔者在2017-9-23号参加了联想的编程笔试。要求用时6-8小时，笔者用了5个半小时完成。
面试的团队主要负责AI客服机器人，所以出的题目就是按照从易到难三种思路开发对话框系统。
其中用到了一个效果看起来还不错的word embeddings——conceptnet-numberbatch
官方github上的下载要很久，使用仅英文版本的话建议使用这个链接进行下载：https://conceptnet.s3.amazonaws.com/downloads/2017/numberbatch/numberbatch-en-17.06.txt.gz
（笔者的5个半小时有1个半小时都在下载这个包）
鉴于目前在网上没有找到太多使用numberbatch的资料，所以笔者将代码发布到git上。望诸君多多指教。


## 以下是题目概述
## 概述

对话框系统对用户说的不同的事情有不同的反应。例如，当用户说“告诉我一个故事”的时候，对话系统会询问用户想听什么样的故事，或继续讲故事。当用户说“我想玩游戏”时，系统将开始与用户进行游戏。工程师为对话系统开发了不同的模块，如故事，歌曲，游戏，笑话等。这个对话系统是状态机，每个模块代表不同的状态，上面列出的每个模块都是一个状态。

对于这个编码挑战，我们将实现一个函数的多个版本，该函数返回系统应该转换到的下一个状态。该功能需要多个输入。其中一个是用户所说的，我们称之为**查询**。每个状态都有**表示状态内容的关键短语**。例如，对于该系统唱歌的状态，关键短语可以是“唱”，“歌”，“音乐”。所有可能的下一个状态的所有关键短语也是此功能的输入。为了简单起见，我们假设每个状态只有一个关键短语，它是一个字符串，“下一个状态”仅由可能的下一个状态和查询的关键短语决定。本质上，我们要实现一个函数，它将**查询**（字符串）和**关键短语**（string）的列表作为输入，并返回与查询最匹配的关键短语的索引。

以下是此编码挑战的详细说明。 **将所有代码写在state_transition.py中，并为您创建一个独立的分支代码。用您的名字命名分支。完成后，将您的代码分支推送到Github **。对于您需要的任何算法，请随时使用Google，并使用您认为有用的任何实用程序库。请保持您的代码干净和有组织（分解您的代码与助手功能是鼓励！），如果逻辑是特别复杂的评论。在评估您的代码时，这对于我们的功能和速度将是同样重要的。

## 语言和系统要求
python2或python3 <br>
磁盘上的16GB可用空间（用于下载字矢量）<br>
8GB RAM <br>
良好的互联网连接，我们将下载一个〜8GB的字矢量文件。

## 第一部分：基于字的匹配
确定查询**匹配的最简单的方法**一个关键短语是检查他们是否有通用单词。例如，“我想玩游戏”，“开始游戏”有一个常见的单词“游戏”。为简单起见，假设查询和关键短语中没有标点符号，但请记住查询和关键短语可能包含多个单词，以空格分隔。

对于第一部分，实现返回与查询匹配的关键短语的索引的函数。如果查询匹配多个关键短语，则返回第一个短语的索引。如果没有关键短语匹配，返回-1。

## 第二部分：文档距离匹配
基于字的匹配的明显缺点是查询必须包含关键短语中的确切词以获得匹配。如果用户说“我想唱歌”，关键词是“歌”，则无法匹配。这可以通过使用单词嵌入来改进。词嵌入是单词的向量表示。每个单词映射到该多维向量空间中的唯一位置。生成Word嵌入，使得具有相似含义或共享相同上下文的单词将在此空间中更接近。例如，距离字“sing”和“song”小于“car”和“song”之间的距离。两个词的距离是其向量/嵌入的距离。

现在我们可以计算两个词之间的距离，我们可以用它来计算任何两个字符串之间的间隔，它们有多个单词。 <http://vene.ro/blog/word-movers-distance-in-python.html>给出了计算该距离的方法的很好的描述。仔细阅读并随时使用本博客文章中的代码。在这篇博文中，使用了Google的[word embeddings]（https://drive.google.com/file/d/0B7XkCwpI5KDYNlNUTTlSS21pQmM/edit）。但是，对于我们的实现，我们希望使用更好的词嵌入，可以从<https://github.com/LuminosoInsight/conceptnet-numberbatch>下载。 （没有必要克隆代码并在这个存储库中构建代码，只需下载单词向量，这个链接在repo的README部分提供）。如果您无法弄清楚如何使用“数字”字词嵌入，请改用Google的字嵌入。

对于第二部分，实现计算每个关键词与查询的距离的函数，并返回具有最短距离的关键短语的索引。 （**额外的功劳：如果我们需要重复运行这个功能，可以大大减少内存使用量）实现它**）。

## 第三部分：文档距离匹配与阈值
有时，任何可用的关键短语与查询匹配，只是选择最短距离的短语不是一个好主意。对于此版本的匹配函数，如果所有关键短语的所有距离都大于某个阈值（float），我们希望返回-1。您可以将阈值视为非常简单的线性分类器。对于这个问题，我们不需要学习比这更复杂的classifer。

**这个门槛可以从一个训练集中学到，这是在回购中提供的。任务是尝试不同的阈值（当然，使用代码，而不是手），并选择在训练集上给出最佳精度的阈值**“精度”由功能给出正确的测试用例数量定义指数作为输出，除以总测试用例数。由于我们只学习一个参数：阈值，我们不需要担心过度拟合。没有必要将数据分成训练和测试。

对于第三部分，使用阈值实现匹配函数。报告阈值（单个数字），准确度，并包括用于学习阈值的代码。 ** Samples / generated_test_cases.txt **是包含训练集的JSON文件。

## 其他提示
确保您考虑并处理边缘案例。不是所有的边缘案例都出现在训练集中。


## 程序运行截图如下
#### part1
![image](https://raw.githubusercontent.com/Qt7mira/MarkDownImg/master/img/interview/part1.png)
#### part2
![image](https://raw.githubusercontent.com/Qt7mira/MarkDownImg/master/img/interview/part2.png)
#### part3
![image](https://raw.githubusercontent.com/Qt7mira/MarkDownImg/master/img/interview/part3.png)
